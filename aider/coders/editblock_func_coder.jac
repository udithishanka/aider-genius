import json;

import from ..dump { dump }
import from .base_coder { Coder }
import from .editblock_coder { do_replace }
import from .editblock_func_prompts { EditBlockFunctionPrompts }


class EditBlockFunctionCoder(Coder) {
    with entry {
        functions =

            [<>dict(
                name='replace_lines',
                description='create or update one or more files',
                parameters=<>dict(
                    type='object',
                    required=['explanation', 'edits'],
                    properties=<>dict(
                        explanation=<>dict(
                            type='string',
                            description='Step by step plan for the changes to be made to the code (future tense, markdown format)'
                        ),
                        edits=<>dict(
                            type='array',
                            items=<>dict(
                                type='object',
                                required=['path', 'original_lines', 'updated_lines'],
                                properties=<>dict(
                                    path=<>dict(
                                        type='string',
                                        description='Path of file to edit'
                                    ),
                                    original_lines=<>dict(
                                        type='array',
                                        items=<>dict(type='string'),
                                        description='A unique stretch of lines from the original file, including all whitespace, without skipping any lines'
                                    ),
                                    updated_lines=<>dict(
                                        type='array',
                                        items=<>dict(type='string'),
                                        description='New content to replace the `original_lines` with'
                                    )
                                )
                            )
                        )
                    )
                )
            )];
    }

    def init(self: EditBlockFunctionCoder, code_format: Any, *args: Any, **kwargs: Any) {
        raise RuntimeError(
            'Deprecated, needs to be refactored to support get_edits/apply_edits'
        ) ;
        self.code_format = code_format;
        if (code_format == 'string') {
            original_lines =
                <>dict(
                    type='string',
                    description='A unique stretch of lines from the original file, including all whitespace and newlines, without skipping any lines'
                );
            updated_lines =
                <>dict(
                    type='string',
                    description='New content to replace the `original_lines` with'
                );
            self.functions[ 0 ][ 'parameters' ][ 'properties' ][ 'edits' ][ 'items' ][ 'properties' ][ 'original_lines' ] =
                original_lines;
            self.functions[ 0 ][ 'parameters' ][ 'properties' ][ 'edits' ][ 'items' ][ 'properties' ][ 'updated_lines' ] =
                updated_lines;
        }
        self.gpt_prompts = EditBlockFunctionPrompts();
        <>super().init(*args, _=kwargs);
    }

    def render_incremental_response(self: EditBlockFunctionCoder, final: Any = False) {
        if self.partial_response_content {
            return self.partial_response_content;
        }
        args = self.parse_partial_args();
        res = json.dumps(args, indent=4);
        return res;
    }

    def _update_files(self: EditBlockFunctionCoder) {
        name = self.partial_response_function_call.get('name');

            if
            (name and (name != 'replace_lines') )
            {
            raise ValueError(
                f"'Unknown function_call name="'{name}'", use name="replace_lines"'"
            ) ;
            }
        args = self.parse_partial_args();
        not args
            if
            {
            return;
            }
        edits = args.get('edits', []);
        edited = <>set();
        for edit in edits {
            path = get_arg(edit, 'path');
            original = get_arg(edit, 'original_lines');
            updated = get_arg(edit, 'updated_lines');
            full_path = self.allowed_to_edit(path);
            content = self.io.read_text(full_path);
            content = do_replace(full_path, content, original, updated);
            if content { self.io.write_text(full_path, content); edited.add(path); continue; }
            self.io.tool_error(f"'Failed to apply edit to '{path}");
        if ((self.code_format == 'list') or (<>type(original) is <>list) ) {
            original = '\n'.join(original);
        } if ((self.code_format == 'list') or (<>type(updated) is <>list) ) {
            updated = '\n'.join(updated);
        } if (original and not original.endswith('\n') ) {
            original += '\n';
        } if (updated and not updated.endswith('\n') ) {
            updated += '\n';
        } not full_path
            if
            {
            continue;
            } }
        return edited;
    }
}


def get_arg(edit: Any, arg: Any) {

        if
        (arg not in edit)
        {
        raise ValueError(f"'Missing `'{arg}'` parameter: '{edit}") ;
        }
    return edit[ arg ];
}