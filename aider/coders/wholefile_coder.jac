import from pathlib { Path }

import from aider { diffs }

import from ..dump { dump }
import from .base_coder { Coder }
import from .wholefile_prompts { WholeFilePrompts }


"""A coder that operates on entire files for code modifications."""
class WholeFileCoder(Coder) {
    with entry {
        edit_format = 'whole';
        gpt_prompts = WholeFilePrompts();
    }

    def render_incremental_response(self: WholeFileCoder, final: Any) {
        try {
            return self.get_edits(mode='diff');
        } except ValueError {
            return self.get_multi_response_content_in_progress();
        }
    }

    def get_edits(self: WholeFileCoder, mode: Any = 'update') {
        content = self.get_multi_response_content_in_progress();
        chat_files = self.get_inchat_relative_files();
        output = [];
        lines = content.splitlines(keepends=True);
        edits = [];
        saw_fname = None;
        fname = None;
        fname_source = None;
        new_lines = [];

            for
            (i, line)
            in
            enumerate(lines)
            {
            if {
                (line.startswith(self.fence[ 0 ]) or line.startswith(self.fence[ 1 ]) )
                if (fname is not None) { saw_fname = None; full_path =
                    self.abs_root_path(fname); if (mode == 'diff') {
                    output += self.do_live_diff(full_path, new_lines, True);
                }
                    else
                    {
                    edits.append((fname, fname_source, new_lines));
                    }
                 fname = None; fname_source = None; continue; }
                if (i > 0) {
                    fname_source = 'block';
                    fname = lines[ (i - 1) ].strip();
                    fname = fname.strip('*');
                    fname = fname.rstrip(':');
                    fname = fname.strip('`');
                    fname = fname.lstrip('#');
                    fname = fname.strip();
                if (len(fname) > 250) {
                    fname = '';
                } if (fname and (fname not in chat_files)
                and (Path(fname).name in chat_files)
                ) {
                    fname = Path(fname).name;
                } }
                if not fname {
                    if saw_fname {
                        fname = saw_fname;
                        fname_source = 'saw';
                    } elif (len(chat_files) == 1) {
                        fname = chat_files[ 0 ];
                        fname_source = 'chat';
                    }
                        else
                        {
                        raise ValueError(
                            f"'No filename provided before '{self.fence[ 0 ]}' in file listing'"
                        ) ;
                        }

                }
            } elif (fname is not None) {
                new_lines.append(line);
            }
                else
                {
                for word in line.strip().split() {
                    word = word.rstrip('.:,;!');
                    for chat_file in chat_files {
                        quoted_chat_file = f"'`'{chat_file}'`'";
                    if (word == quoted_chat_file) {
                        saw_fname = chat_file;
                    } }
                }
                output.append(line);
                }

            }

            if
            (mode == 'diff')
            {
            if (fname is not None) {
                full_path = (Path(self.root) / fname).absolute();
                output += self.do_live_diff(full_path, new_lines, False);
            }
            return '\n'.join(output);
            }
        if fname {
            edits.append((fname, fname_source, new_lines));
        }
        seen = <>set();
        refined_edits = [];
        for source in ('block', 'saw', 'chat') {

                for
                (fname, fname_source, new_lines)
                in
                edits
                {

                    if
                    (fname_source != source)
                    {
                    continue;
                    }

                    if
                    (fname in seen)
                    {
                    continue;
                    }
                seen.add(fname);
                refined_edits.append((fname, fname_source, new_lines));
                }
        }
        return refined_edits;
    }

    def apply_edits(self: WholeFileCoder, edits: Any) {
        for (path, fname_source, new_lines) in edits {
            full_path = self.abs_root_path(path);
            new_lines = ''.join(new_lines);
            self.io.write_text(full_path, new_lines);
        }
    }

    def do_live_diff(self: WholeFileCoder, full_path: Any, new_lines: Any, final: Any) {
        if Path(full_path).exists() {
            orig_lines = self.io.read_text(full_path);
        if (orig_lines is not None) {
            orig_lines = orig_lines.splitlines(keepends=True);
            show_diff =
                diffs.diff_partial_update(orig_lines, new_lines, final=final).splitlines();
            return show_diff;
        } }
        output = ((['```'] + new_lines) + ['```']);
        return output;
    }
}