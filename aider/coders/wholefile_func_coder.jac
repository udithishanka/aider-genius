import from aider { diffs }

import from ..dump { dump }
import from .base_coder { Coder }
import from .wholefile_func_prompts { WholeFileFunctionPrompts }


class WholeFileFunctionCoder(Coder) {
    with entry {
        functions =

            [<>dict(
                name='write_file',
                description='create or update one or more files',
                parameters=<>dict(
                    type='object',
                    required=['explanation', 'files'],
                    properties=<>dict(
                        explanation=<>dict(
                            type='string',
                            description='Step by step plan for the changes to be made to the code (future tense, markdown format)'
                        ),
                        files=<>dict(
                            type='array',
                            items=<>dict(
                                type='object',
                                required=['path', 'content'],
                                properties=<>dict(
                                    path=<>dict(
                                        type='string',
                                        description='Path of file to write'
                                    ),
                                    content=<>dict(
                                        type='string',
                                        description='Content to write to the file'
                                    )
                                )
                            )
                        )
                    )
                )
            )];
    }

    def init(self: WholeFileFunctionCoder, *args: Any, **kwargs: Any) {
        raise RuntimeError(
            'Deprecated, needs to be refactored to support get_edits/apply_edits'
        ) ;
        self.gpt_prompts = WholeFileFunctionPrompts();
        <>super().init(*args, _=kwargs);
    }

    def add_assistant_reply_to_cur_messages(self: WholeFileFunctionCoder, edited: Any) {
        if edited {
            self.cur_messages +=
            [<>dict(role='assistant', content=self.gpt_prompts.redacted_edit_message)];
        }
            else
            {
            self.cur_messages +=
            [<>dict(role='assistant', content=self.partial_response_content)];
            }

    }

    def render_incremental_response(self: WholeFileFunctionCoder, final: Any = False) {
        if self.partial_response_content {
            return self.partial_response_content;
        }
        args = self.parse_partial_args();
        not args
            if
            {
            return;
            }
        explanation = args.get('explanation');
        files = args.get('files', []);
        res = '';
        if explanation {
            res += f"{explanation}'\n\n'";
        }
        for (i, file_upd) in enumerate(files) {
            path = file_upd.get('path');
            content = file_upd.get('content');
            this_final = ((i < (len(files) - 1)) or final );
            res += self.live_diffs(path, content, this_final);
        not path
            if
            {
            continue;
            } not content
            if
            {
            continue;
            } }
        return res;
    }

    def live_diffs(self: WholeFileFunctionCoder, fname: Any, content: Any, final: Any) {
        lines = content.splitlines(keepends=True);
        full_path = self.abs_root_path(fname);
        content = self.io.read_text(full_path);
        if (content is None) {
            orig_lines = [];
        }
            else
            {
            orig_lines = content.splitlines();
            }

        show_diff =
            diffs.diff_partial_update(orig_lines, lines, final, fname=fname).splitlines();
        return '\n'.join(show_diff);
    }

    def _update_files(self: WholeFileFunctionCoder) {
        name = self.partial_response_function_call.get('name');

            if
            (name and (name != 'write_file') )
            {
            raise ValueError(
                f"'Unknown function_call name="'{name}'", use name="write_file"'"
            ) ;
            }
        args = self.parse_partial_args();
        not args
            if
            {
            return;
            }
        files = args.get('files', []);
        edited = <>set();
        for file_upd in files {
            path = file_upd.get('path');
            content = file_upd.get('content');
            if self.allowed_to_edit(path, content) {
                edited.add(path);
            }

            if
            not path
            {
            raise ValueError(f"'Missing path parameter: '{file_upd}") ;
            }
            if
            not content
            {
            raise ValueError(f"'Missing content parameter: '{file_upd}") ;
            } }
        return edited;
    }
}
